# ShopApp
Repository for web app and mobile exam

Relazione “Progettazione di Applicazioni Web e Mobili” 
Shop App 
Emiliani Francesco, Caggiano Matteo, Malaccari Francesco 
Introduzione 
ShopApp è un'applicazione mobile che funge da E-Commerce, consentendo il processo di vendita e acquisto di un catalogo di prodotti. L'applicazione segue il pattern architetturale MVC (ModelView-Controller), che suddivide le responsabilità in tre componenti distinti: 
 Model: Si occupa della gestione dei dati, della logica di elaborazione e dell'interazione con il database. 
 View: Rappresenta l'interfaccia utente, mostrando i dati e interagendo con l'utente. 
 Controller: Fa da intermediario tra il Model e la View. Riceve le richieste dell'utente e le instrada in modo appropriato al Model, elaborando la logica necessaria e aggiornando la View con i risultati. 
L'applicazione è stata sviluppata con un'organizzazione delle responsabilità tra Frontend e Backend. Il Frontend gestisce l'interazione diretta con l'utente, mostrando l'interfaccia e raccogliendo le informazioni inserite. Il Backend, invece, si occupa di gestire il salvataggio e l'aggiornamento dei dati nel database, garantendo che le informazioni ottenute siano correttamente conservate. 
 
Struttura e tecnologie utilizzate 
L'applicazione è sviluppata seguendo il paradigma REST e rispetta i principi fondamentali associati ad esso. Questi principi includono: 
 Architettura Client-Server: L'applicazione segue una struttura client-server in cui il client, ovvero il Frontend, si occupa dell'interfaccia utente e delle interazioni con l'utente, mentre il server, il Backend, gestisce le richieste del client e le elabora. 
 Statelessness: L'applicazione è stateless, il che significa che ogni richiesta del client al server contiene tutte le informazioni necessarie per elaborare la richiesta. Il server non mantiene lo stato delle sessioni client, semplificando così la scalabilità e la gestione delle richieste. 
 Interfacce uniformi: L'applicazione utilizza interfacce uniformi per le comunicazioni tra il client e il server. Questo si traduce nell'uso dei metodi HTTP standard come GET, POST, PUT e DELETE per le operazioni di lettura, scrittura, aggiornamento e cancellazione dei dati. 
 Sistema a livelli: L'applicazione è progettata con un sistema a livelli, in cui i componenti possono essere distribuiti su più strati.  
 
L'applicazione è divisa in due sezioni principali: 
 Frontend: Questa sezione gestisce l'interfaccia utente e le interazioni con l'utente. Si occupa di presentare i dati e raccogliere le informazioni inserite dagli utenti. 
 Backend: Questa sezione è responsabile della gestione delle richieste del client e dell'elaborazione delle logiche. Si occupa di salvare e recuperare i dati dal database, rispondere alle richieste del client e garantire il corretto funzionamento dell'applicazione. 
 
Frontend 
Per la realizzazione dell'applicazione, lato frontend, è stato utilizzato il framework Flutter insieme al linguaggio di programmazione Dart. Flutter offre la possibilità di sviluppare app per iOS e Android utilizzando un unico codice base. Questo ha permesso di ottenere una maggiore efficienza nello sviluppo e la possibilità di distribuire l'app su entrambe le piattaforme senza dover scrivere codice specifico per ognuna di esse. 
Per la simulazione del dispositivo mobile e il test delle funzionalità del codice, è stato utilizzato il software Android Studio. Esso ha fornito un'anteprima visiva dell'app e ha consentito di testare le funzionalità implementate nel codice. È stata scelta la combinazione di Flutter e Dart perché Flutter utilizza il motore di rendering SKIA, che consente di ottenere prestazioni elevate in termini di fluidità e reattività dell'interfaccia utente. Inoltre, l'approccio AOT (Ahead-of-time) di Flutter consente di compilare il codice sorgente in codice macchina nativo prima dell'esecuzione, contribuendo a migliorare le prestazioni complessive dell'applicazione. 
 
Backend 
Per lo sviluppo del backend dell'applicazione, è stato utilizzato il framework Spring Boot. Spring Boot è un framework open source basato su Spring, che offre una vasta gamma di funzionalità per lo sviluppo di applicazioni enterprise in Java. Questo framework semplifica la configurazione e l'implementazione di applicazioni Spring, fornendo un approccio rapido e convenzionale allo sviluppo. 
Per la gestione delle dipendenze e la compilazione del progetto, è stato utilizzato Maven. Questo è uno strumento di gestione dei progetti che permette di gestire le dipendenze esterne, compilarle e creare il pacchetto finale dell'applicazione. L'utilizzo di un file pom.xml consente di specificare le dipendenze del progetto e Maven si occupa di scaricarle e gestirle automaticamente. Un altro framework utilizzato è  stato Hibernate , un framework di Object-Relational Mapping (ORM). Hibernate fornisce un'interfaccia tra l'applicazione Java e il database relazionale (nel caso specifico, MySQL). Con questo framwork è possibile mappare le tabelle del database in classi Java e le righe della tabella in oggetti Java. Inoltre, Hibernate gestisce automaticamente le operazioni di persistenza dei dati, come l'inserimento, l'aggiornamento e l'eliminazione dei record, utilizzando il suo linguaggio di query HQL. 
Per quanto riguarda il testing, è stato utilizzato Mockito, un framework di testing per Java. Mockito consente di creare oggetti simulati (mock) per testare il comportamento delle classi o dei componenti in isolamento, senza dipendere dalle loro dipendenze esterne. Questi test sono stati eseguiti utilizzando il framework di test JUnit, che offre strumenti per l'esecuzione di test automatizzati e l'asserzione dei risultati attesi. 
Infine, per testare le API esposte dal backend e verificare le chiamate HTTP, è stato utilizzato Postman, uno strumento di sviluppo e testing API che consente di inviare richieste HTTP ai servizi web e di analizzare le risposte ricevute.  
 
Descrizione e tecniche utilizzate 
Per la sicurezza della nostra app, si sono utilizzate diverse tecniche.  
Abbiamo implementato la tecnica CORS (Cross-Origin Resource Sharing) per prevenire attacchi di tipo cross-origin, che possono compromettere la sicurezza e la privacy degli utenti. CORS definisce regole per consentire o limitare l'accesso alle risorse da parte di domini diversi, consentendo solo le richieste provenienti da origini attendibili.  
Per garantire la sicurezza contro attacchi di SQL Injection, abbiamo utilizzato le funzionalità fornite da Hibernate, che offre metodi di interrogazione dei database che evitano l'iniezione di codice SQL dannoso, proteggendo così l'integrità e la sicurezza dei dati. Inoltre, abbiamo implementato controlli per verificare la correttezza e l'affidabilità dei dati in input ricevuti dal frontend, al fine di evitare l'esecuzione di query SQL malevole.  
Per garantire la sicurezza delle password degli utenti, abbiamo utilizzato la tecnica di hash con secret e salt. Le password vengono concatenate a una stringa casuale (salt) e a un valore segreto (secret), e quindi sottoposte a un algoritmo di hash, nel nostro caso SHA256. Questa tecnica protegge le password dagli attacchi brute force e dal cracking delle password mediante tabelle rainbow. In caso di eventuali leak, le password sarebbero difficilmente decifrabili senza conoscere il salt e il secret utilizzati. 
La nostra implementazione implementazione dell'autenticazione degli utenti sfrutta Firebase come sistema di gestione dell'accesso alle applicazioni, integrando la classica autenticazione tramite database. In particolare, abbiamo utilizzato la sezione dedicata a Google per consentire agli utenti di accedere utilizzando i propri account Google. Dopo aver registrato l'applicazione su Firebase e importato il file JSON fornito, abbiamo creato un oggetto "GoogleSignIn" per gestire le operazioni di accesso. Attraverso i metodi forniti da "googleSignIn", come "signIn()" e "signOut()", è stato possibile effettuare l'accesso e il logout utilizzando l'account Google dell'utente. 
L'autenticazione viene gestita da Firebase, che include anche un processo di verifica dell'identità a due fattori per garantire la sicurezza. Inoltre, abbiamo utilizzato il pacchetto 
"email_auth/email_auth.dart" per implementare la funzionalità di recupero della password tramite codice OTP (One-Time Password) inviato via email. L'oggetto "EmailOTP" ci ha consentito di configurare le impostazioni, inviare il codice OTP all'indirizzo email specificato e verificarne la correttezza. 
Abbiamo, inoltre, adottato la tecnica JSON Web Token (JWT) per garantire un'autenticazione e un'autorizzazione sicure degli utenti nelle nostra applicazioni. Utilizzando i token di accesso generati, che contengono informazioni sull'identità dell'utente e le relative autorizzazioni, possiamo verificare l'autenticità dell'utente e consentire l'accesso alle risorse autorizzate. Con JWT, evitiamo la necessità di memorizzare lo stato di sessione lato server e permettiamo alle applicazioni di essere stateless, aumentando la scalabilità e semplificando la gestione delle richieste. 
 	 
Per quanto riguarda il contesto delle chiamate HTTP all'API lato frontend, abbiamo implementato due tecniche: il debouncing e il caching, per ottimizzare le prestazioni dell'applicazione e ridurre il carico sul server. 
La tecnica di debouncing è stata utilizzata per limitare la frequenza delle richieste inviate al server durante le interazioni degli utenti. Quando l'utente interagisce con l'interfaccia il debounce ritarda l'esecuzione della richiesta per un breve periodo di tempo dopo che l'utente ha smesso di agire. In questo modo, se l'utente continua a interagire rapidamente, la richiesta non verrà inviata ad ogni singola azione, ma verrà ritardata fino a quando l'utente si ferma per un breve momento. Questo evita il sovraccarico del server con troppe richieste ridondanti e migliora l'efficienza delle interazioni dell'utente. 
Il caching, invece, è una tecnica utilizzata per memorizzare temporaneamente i dati in modo che possano essere riutilizzati rapidamente in futuro, senza dover effettuare una nuova richiesta al server. Ciò riduce il tempo di latenza e migliora le prestazioni complessive dell'applicazione.  Utilizzando entrambe le tecniche insieme, il debounce per limitare la frequenza delle richieste durante le interazioni dell'utente e il caching per memorizzare le risposte delle chiamate HTTP, si ottiene un sistema più efficiente. Le richieste vengono inviate solo quando necessario, dopo una breve pausa di inattività da parte dell'utente, riducendo il sovraccarico del server. Inoltre, i dati vengono recuperati rapidamente dall’applicazione quando disponibili, evitando la necessità di effettuare nuove richieste al server. Questo porta a prestazioni migliorate complessive dell'applicazione e a una migliore esperienza utente 
 
